#!/usr/bin/env python

# ROS version written by Minkyu Kim

#The MIT License (MIT)
#Copyright (c) 2016 Massimiliano Patacchiola
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
#MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
#CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
#SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#In this example the Particle Filter is used in order to stabilise some noisy detection.
#The Backprojection algorithm is used in order to find the pixels that have the same HSV 
#histogram of a predefined template. The template is a subframe of the main image or an external
#matrix that can be used as a filter. We track the object taking the contour with the largest area
#returned by a binary mask (blue rectangle). The center of the contour is the tracked point. 
#To test the Particle Filter we inject noise in the measurements returned by the Backprojection. 
#The Filter can absorbe the noisy measurements, giving a stable estimation of the target center (green dot).

#COLOR CODE:
#BLUE: the rectangle containing the target. Noise makes it shaky (unstable measurement).
#GREEN: the point estimated from the Particle Filter.
#RED: the particles generated by the filter.

import cv2
import roslib
import sys
import rospy
import numpy as np
from cv_bridge import CvBridge, CvBridgeError
import select, termios, tty
from sensor_msgs.msg import Image
from std_msgs.msg import String
from os import listdir
import os
import tensorflow as tf

from deepgaze.color_detection import BackProjectionColorDetector
from deepgaze.mask_analysis import BinaryMaskAnalyser
from deepgaze.motion_tracking import ParticleFilter


class ObjectTracker(object):
    def __init__(self, wait=0.0):

        self.image_pub = rospy.Publisher("objet_tracker/particle_filter",Image,queue_size=10)
        dirname = os.path.dirname(__file__)
        self.known_folder = dirname
        self.filename1=self.known_folder+"/flesh2.png"
        template = cv2.imread(self.filename1) #Load the image

        self.my_mask_analyser = BinaryMaskAnalyser()
        self.my_back_detector = BackProjectionColorDetector()
        self.my_back_detector.setTemplate(template) #Set the template 
        tot_particles =300
        self.std=10;
        self.my_particle = ParticleFilter(480, 640, tot_particles)
        # self.my_particle = ParticleFilter(640, 480, tot_particles)
        self.noise_probability = 0.10 #in range [0, 1.0]

        # image_topic = "/hsrb/head_rgbd_sensor/rgb/image_rect_color"
        # image_topic = "/camera/rgb/image_color"
        image_topic = "/usb_cam/image_raw"
	rospy.Subscriber(image_topic, Image, self.image_callback)
        self.bridge = CvBridge()
	
    def image_callback(self,msg):
        # print('image_callback: ')
        try:
            frame   = self.bridge.imgmsg_to_cv2(msg,"bgr8")
            frame_mask = self.my_back_detector.returnMask(frame, morph_opening=True, blur=True, kernel_size=5, iterations=2)
        
            if(self.my_mask_analyser.returnNumberOfContours(frame_mask) > 0):
                x_rect,y_rect,w_rect,h_rect = self.my_mask_analyser.returnMaxAreaRectangle(frame_mask)
                x_center, y_center = self.my_mask_analyser.returnMaxAreaCenter(frame_mask)
                #Adding noise to the coords
                coin = np.random.uniform()
                if(coin >= 1.0-self.noise_probability): 
                    x_noise = int(np.random.uniform(-300, 300))
                    y_noise = int(np.random.uniform(-300, 300))
                else: 
                    x_noise = 0
                    y_noise = 0
                x_rect += x_noise
                y_rect += y_noise
                x_center += x_noise
                y_center += y_noise
                cv2.rectangle(frame, (x_rect,y_rect), (x_rect+w_rect,y_rect+h_rect), [255,0,0], 2) #BLUE rect

                original_x_rect=x_rect
                original_y_rect=y_rect

                #Predict the position of the target
                self.my_particle.predict(x_velocity=0, y_velocity=0, std=self.std)

                #Drawing the particles.
                self.my_particle.drawParticles(frame)

               #Estimate the next position using the internal model
                x_estimated, y_estimated, _, _ = self.my_particle.estimate()
                cv2.circle(frame, (x_estimated, y_estimated), 3, [0,255,0], 5) #GREEN dot

               #Update the filter with the last measurements
                self.my_particle.update(x_center, y_center)
                const=30
                entropy=[]

                #generating samples z_k+1,
                sample_entropy=self.my_particle.update(x_center+const, y_center+const)
                entropy.append(sample_entropy)
                x_rect=original_x_rect+const
                y_rect=original_y_rect+const
                cv2.rectangle(frame, (x_rect,y_rect), (x_rect+w_rect,y_rect+h_rect), [255,125,0], 3) #BLUE rect

                x_rect=original_x_rect+const
                y_rect=original_y_rect-const
                sample_entropy2=self.my_particle.update(x_center+const, y_center-const)
                entropy.append(sample_entropy2)
                cv2.rectangle(frame, (x_rect,y_rect), (x_rect+w_rect,y_rect+h_rect), [255,125,0], 3) #BLUE rect

                x_rect=original_x_rect-const
                y_rect=original_y_rect+const
                sample_entropy3=self.my_particle.update(x_center-const, y_center+const)
                entropy.append(sample_entropy3)
                cv2.rectangle(frame, (x_rect,y_rect), (x_rect+w_rect,y_rect+h_rect), [255,125,0], 2) #BLUE rect

                x_rect=original_x_rect-const
                y_rect=original_y_rect-const
                sample_entropy4=self.my_particle.update(x_center-const, y_center-const)
                entropy.append(sample_entropy4)
                cv2.rectangle(frame, (x_rect,y_rect), (x_rect+w_rect,y_rect+h_rect), [255,125,0], 2) #BLUE rect
                # self.my_particle.update_normal(x_center, y_center)

                # entropy = self.my_particle.get_entropy()
                rospy.loginfo("e1 : %.4lf, e2: %.4lf, e3: %.4lf, e4 : %.4lf ", sample_entropy, sample_entropy2,sample_entropy3,sample_entropy4)
                sorted_entropy = sorted(((v,i) for i, v in enumerate(entropy)),reverse=False)
                # for i, (value,index) in enumerate(sorted_entropy):
                    # rospy.loginfo("value : %lf, idx: %d", value, index)

                print "maximum index" : sorted_entropy[0][1]

                # print sorted_entropy[0,1]
                # rospy.loginfo("maximum index :%d", sorted_entropy(index")
                # rospy.loginfo("e1 : %.4lf, e2: %.4lf, e3: %.4lf, e4 : %.4lf ", sample_entropy, sample_entropy2,sample_entropy3,sample_entropy4)
               #Resample the particles
                self.my_particle.resample('multinomal')

                # entropy = self.my_particle.get_entropy()
                # rospy.loginfo("resampled entropy : %.4lf", entropy)
               #Writing in the output file
               # out.write(frame)

                # self.image_pub.publish(self.bridge.cv2_to_imgmsg(frame, "bgr8"))
                # rospy.sleep(3)
            cv2.imshow("image_window", frame)
            # cv2.imshow('Mask', frame_mask) #show on window
            cv2.waitKey(10)
            # if cv2.waitKey(3) & 0xFF == ord('q'):
                # break #Exit when Q is pressed

        except CvBridgeError, e:
            print(e)


    def listener(self,wait=0.0):
        rospy.spin() 


if __name__ == '__main__':
        rospy.init_node('particle_filter_test')
	# print("Initialize node")
        tracker_manager = ObjectTracker(sys.argv[1] if len(sys.argv) >1 else 0.0)
	tracker_manager.listener()	

