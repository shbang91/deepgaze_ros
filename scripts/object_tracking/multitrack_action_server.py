#!/usr/bin/env python

# ROS version written by Minkyu Kim

#The MIT License (MIT)
#Copyright (c) 2016 Massimiliano Patacchiola
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
#MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
#CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
#SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#In this example the Particle Filter is used in order to stabilise some noisy detection.
#The Backprojection algorithm is used in order to find the pixels that have the same HSV 
#histogram of a predefined template. The template is a subframe of the main image or an external
#matrix that can be used as a filter. We track the object taking the contour with the largest area
#returned by a binary mask (blue rectangle). The center of the contour is the tracked point. 
#To test the Particle Filter we inject noise in the measurements returned by the Backprojection. 
#The Filter can absorbe the noisy measurements, giving a stable estimation of the target center (green dot).

#COLOR CODE:
#BLUE: the rectangle containing the target. Noise makes it shaky (unstable measurement).
#GREEN: the point estimated from the Particle Filter.
#RED: the particles generated by the filter.

import cv2
import roslib
import sys
import rospy
import numpy as np
from cv_bridge import CvBridge, CvBridgeError
import select, termios, tty
from sensor_msgs.msg import Image
from std_msgs.msg import String
from os import listdir
import os
from os.path import isfile, join, exists
import tensorflow as tf

import actionlib
from deepgaze_ros.msg import *
from std_msgs.msg import Float32MultiArray, Int8MultiArray
from deepgaze.color_detection import BackProjectionColorDetector
from deepgaze.mask_analysis import BinaryMaskAnalyser
from deepgaze.motion_tracking import ParticleFilter
from deepgaze_ros.srv import learn_clothes, learn_clothesRequest, learn_clothesResponse
from villa_yolocloud.msg import BboxInfo
from villa_yolocloud.msg import ObjectInfo
from villa_yolocloud.msg import ObjectInfoArray
from darknet_ros_msgs.msg import BoundingBoxes, BoundingBox


class ObjectTracker(object):
    def __init__(self, name,  wait=0.0):

        self._action_name= name

        #ROS action started
        self._as = actionlib.SimpleActionServer(self._action_name, deepgaze_ros.msg.MultiTrackAction, execute_cb=self.execute_cb, auto_start = False)
        self._as.start()

        self.Init_track=False
        self.target_ids=[]
        self.target_strings=[]
        self.trackers=[]
        self.templete_trackers=[]
        self.my_back_detectors=[]
        self.mask_analysers=[]
        # self.color_track=False
        self.color_track=True
        self.infoarray = ObjectInfoArray()
        self.image_pub = rospy.Publisher("objet_tracker/particle_filter",Image,queue_size=10)
        self.objimage_pub1 = rospy.Publisher("object1_photo",Image,queue_size=10)
        self.objimage_pub2 = rospy.Publisher("object2_photo",Image,queue_size=10)
        self.objimage_pub3 = rospy.Publisher("object3_photo",Image,queue_size=10)
        # rospy.Service('/relearn_clothes', learn_clothes, self.learning_dataset)
        dirname = os.path.dirname(__file__)
        self.known_folder = dirname
        self.savepicture=False
        # self.filename1=self.known_folder+"/object2.png"
        self.filename1=self.known_folder+"/clothes0.png"
        template = cv2.imread(self.filename1) #Load the image
        # self.my_mask_analyser = BinaryMaskAnalyser()
        # self.my_back_detector = BackProjectionColorDetector()
        # self.my_back_detector.setTemplate(template) #Set the template 
        self.tot_particles =1000
        self.std=20;
        # self.my_particle = ParticleFilter(480, 640, tot_particles)
        # self.my_particle = ParticleFilter(640, 480, tot_particles)
        self.noise_probability = 0.10 #in range [0, 1.0]
        self.save_time = rospy.get_time()

        # image_topic = "/hsrb/head_rgbd_sensor/rgb/image_rect_color"
        image_topic = "/camera/rgb/image_color"
	rospy.Subscriber(image_topic, Image, self.image_callback)
        objinfo_topic = "/objects_info"
	rospy.Subscriber(objinfo_topic, ObjectInfoArray, self.object_callback)
        darknet_topic = "/darknet_ros/bounding_boxes"
	rospy.Subscriber(darknet_topic, BoundingBoxes, self.yolo_callback)

        self.filter_result_pub=rospy.Publisher('/object_tracker/positions',Float32MultiArray,queue_size=10)
        self.bridge = CvBridge()

    def execute_cb(self, goal):
        for id in goal.idset.data:
            rospy.loginfo("target set : id :%d",  id)
            self.target_ids.append(id)
            for index in range(len(self.infoarray.objectinfos)):
                if self.infoarray.objectinfos[index].id == id:
                    self.target_strings.append(self.infoarray.objectinfos[index].label)
                    rospy.loginfo("tracking object label : %s",self.infoarray.objectinfos[index].label)

            indiv_particle=ParticleFilter(480, 640, self.tot_particles)
            self.trackers.append(indiv_particle)

        rospy.loginfo("tracking initiated!!")
        self.Init_track=True

        #set initial position of targets
        # for id in self.target_ids:
            # for index in range(len(self.infoarray.objectinfos)):
                # if self.infoarray.objectinfos[index].id == id:

                    # cut_x=int(self.infoarray.objectinfos[index].bbox.x)
                    # cut_y=int(self.infoarray.objectinfos[index].bbox.y)
                    # crop_width=int(self.infoarray.objectinfos[index].bbox.width)
                    # crop_height=int(self.infoarray.objectinfos[index].bbox.height)
                    # object_crop= image_batch[cut_y:cut_y+crop_height, cut_x:cut_x+crop_width]
                    # objfiles.append(object_crop)

        self._as.set_succeeded()

    def learning_dataset(self,req):
        template = cv2.imread(self.filename1) #Load the image
        self.my_mask_analyser = BinaryMaskAnalyser()
        self.my_back_detector = BackProjectionColorDetector()
        self.my_back_detector.setTemplate(template) #Set the template 
        tot_particles =2000
        self.std=20;
        self.my_particle = ParticleFilter(480, 640, tot_particles)
        self.noise_probability = 0.10 #in range [0, 1.0]
        print("training done")
        return learn_clothesResponse()

    def yolo_callback(self,msg):
        self.bounding_boxes = msg.bounding_boxes

        if self.Init_track:
            for bbox in self.bounding_boxes:
                for id in range(len(self.target_ids)):
                    if bbox.Class == self.target_strings[id]:
                        self.update_trackers(id,bbox.xmin,bbox.xmax,bbox.ymin,bbox.ymax)
                        self.trackers[id].resample()


    def object_callback(self,msg):
        # rospy.loginfo("object_callback")
        self.infoarray=msg
        if self.Init_track:
            for id in range(len(self.target_ids)):
                for index in range(len(self.infoarray.objectinfos)):
                    if self.infoarray.objectinfos[index].id == self.target_ids[id]:
                        bbox = self.infoarray.objectinfos[index].bbox
                        x_center=bbox.x+bbox.width/2
                        y_center=bbox.y+bbox.height/2
                        self.update_trackers(id,bbox.x,bbox.x+bbox.width,bbox.y,bbox.y+bbox.height)
                        self.trackers[id].resample()

     
            self.image_pub.publish(self.bridge.cv2_to_imgmsg(self.frame, "bgr8"))


    def crop_objects(self, image_data):
        image_batch = image_data
        objfiles = []
        for index in range(len(self.infoarray.objectinfos)):
            for id in range(len(self.target_ids)):
                for index in range(len(self.infoarray.objectinfos)):
                    if self.infoarray.objectinfos[index].id == self.target_ids[id]:
                        cut_x=int(self.infoarray.objectinfos[index].bbox.x)
                        cut_y=int(self.infoarray.objectinfos[index].bbox.y)
                        crop_width=int(self.infoarray.objectinfos[index].bbox.width)
                        crop_height=int(self.infoarray.objectinfos[index].bbox.height)
                        object_crop= image_batch[cut_y:cut_y+crop_height, cut_x:cut_x+crop_width]
                        objfiles.append(object_crop)

        if self.savepicture==False:
           self.save_pictures(objfiles)
           self.save_picture=True

        #photo update every 15 seconds
        cur_time = rospy.get_time()
        duration = cur_time - self.save_time
        #not required for now ---- reset templete
        # if duration >20.0:
            # if self.savepicture==False:
                # self.save_pictures(objfiles)
            # else:
                # return objfiles
            
        return objfiles
    def save_pictures(self, images):
        # self.my_back_detectors=[]
        # for index in range(len(images)):
        for id in range(len(self.target_ids)):
            self.savedname = self.known_folder+"/object" + str(id) + ".png"
            cv2.imwrite(self.savedname, images[id])
            print "file_path", self.savedname

            if len(images)>0:
                print('save picture')
                self.savepicture=True
            #save Time
            rospy.sleep(1.5)
            template = cv2.imread(self.savedname) #Load the image
            my_mask_analyser = BinaryMaskAnalyser()
            self.mask_analysers.append(my_mask_analyser)
            my_back_detector = BackProjectionColorDetector()
            my_back_detector.setTemplate(template) #Set the template 
            self.my_back_detectors.append(my_back_detector)
            tot_particles =1500
            self.std=20;
            hog_particle = ParticleFilter(480, 640, tot_particles)
            self.templete_trackers.append(hog_particle)
            self.noise_probability = 0.10 #in range [0, 1.0]
            # rospy.sleep(1)

        # print("training done")
        self.save_time=rospy.get_time()

	
    def image_callback(self,msg):
        # print('image_callback: ')
        
        try:
            self.frame   = self.bridge.imgmsg_to_cv2(msg,"bgr8")
            objectsphotos= self.crop_objects(self.frame)


            # if len(objectsphotos)>0:
                # self.objimage_pub1.publish(self.bridge.cv2_to_imgmsg(objectsphotos[0], "bgr8"))
            
            # if len(objectsphotos)>1:
                # self.objimage_pub2.publish(self.bridge.cv2_to_imgmsg(objectsphotos[1], "bgr8"))

            # if len(objectsphotos)>3:
                # self.objimage_pub3.publish(self.bridge.cv2_to_imgmsg(objectsphotos[3], "bgr8"))
            if self.color_track & self.Init_track:
                for id in range(len(self.target_ids)):
                    try:
                        frame_mask = self.my_back_detectors[id].returnMask(self.frame, morph_opening=True, blur=True, kernel_size=5, iterations=2)
                    except:
                        rospy.sleep(2)
                    if(self.mask_analysers[id].returnNumberOfContours(frame_mask) > 0):
                        x_rect,y_rect,w_rect,h_rect = self.mask_analysers[id].returnMaxAreaRectangle(frame_mask)
                        x_center, y_center = self.mask_analysers[id].returnMaxAreaCenter(frame_mask)
                        # Adding noise to the coords
                        coin = np.random.uniform()
                        if(coin >= 1.0-self.noise_probability): 
                            x_noise = int(np.random.uniform(-300, 300))
                            y_noise = int(np.random.uniform(-300, 300))
                        else: 
                            x_noise = 0
                            y_noise = 0
                        x_rect += x_noise
                        y_rect += y_noise
                        x_center += x_noise
                        y_center += y_noise
                        cv2.rectangle(self.frame, (x_rect,y_rect), (x_rect+w_rect,y_rect+h_rect), [255,255,0], 2) #BLUE rect

                        #Predict the position of the target
                        self.templete_trackers[id].predict(x_velocity=0, y_velocity=0, std=self.std)

                        #Drawing the particles.
                        self.templete_trackers[id].drawParticles(self.frame)

                        #Estimate the next position using the internal model
                        x_estimated, y_estimated, _, _ = self.templete_trackers[id].estimate()
                        cv2.circle(self.frame, (x_estimated, y_estimated), 3, [0,125,120], 5) #GREEN dot
                        self.templete_trackers[id].update(x_center, y_center)
                        self.templete_trackers[id].resample()

                #publish_filter result
                # filter_msg=Float32MultiArray()
                # filter_msg.data.append(x_estimated)
                # filter_msg.data.append(y_estimated)
                # self.filter_result_pub.publish(filter_msg)

               #Update the filter with the last measurements
                # self.my_particle.update(x_center, y_center)

               #Resample the particles
                # self.my_particle.resample()

            #--------------------
            if self.Init_track:
                    for bbox in self.bounding_boxes:
                        for id in range(len(self.target_ids)):
                            if bbox.Class == self.target_strings[id]:
                                self.update_trackers(id,bbox.xmin,bbox.xmax,bbox.ymin,bbox.ymax)

                    # self.update_trackers(id,self.yolo_bbs[id].xmin, self.yolo_bbs[id].xmax, self.yolo_bbs[id].ymin, self.yolo_bbs[id].ymax)
                        # if self.infoarray.objectinfos[index].id == self.target_ids[id]:
                            # bbox = self.infoarray.objectinfos[index].bbox
                            # x_center=bbox.x+bbox.width/2
                            # y_center=bbox.y+bbox.height/2
                            # self.update_trackers(id,bbox.x,bbox.x+bbox.width,bbox.y,bbox.y+bbox.height)
            #--------------------------------------------



               #Writing in the output file
               # out.write(frame)
            self.image_pub.publish(self.bridge.cv2_to_imgmsg(self.frame, "bgr8"))


            # cv2.imshow("image_window", frame)
            # cv2.imshow('Mask', frame_mask) #show on window
            # cv2.waitKey(3)
            # if cv2.waitKey(3) & 0xFF == ord('q'):
                # break #Exit when Q is pressed

        except CvBridgeError, e:
            print(e)

    def update_trackers(self, idx, bbox_xmin, bbox_xmax, bbox_ymin, bbox_ymax):
        x_meas = bbox_xmin+(bbox_xmax-bbox_xmin)/2
        y_meas = bbox_ymin+(bbox_ymax-bbox_ymin)/2
        self.trackers[idx].predict(x_velocity=0, y_velocity=0, std=self.std)
        self.trackers[idx].drawParticles(self.frame)
        x_estimated, y_estimated, _, _ = self.trackers[idx].estimate()
        cv2.circle(self.frame, (x_estimated, y_estimated), 3, [0,255,0], 5) #GREEN dot
        self.trackers[idx].update(x_meas, y_meas)
        cv2.rectangle(self.frame, (int(bbox_xmin),int(bbox_ymin)), (int(bbox_xmax),int(bbox_ymax)), [255,0,0], 2) #BLUE rect
        # self.trackers[idx].resample()


    def listener(self,wait=0.0):
        rospy.spin() 


if __name__ == '__main__':
        rospy.init_node('multi_particle_filte')
	# print("Initialize node")
        tracker_manager = ObjectTracker('multi_tracker_action')
        rospy.loginfo("multi_tracker actioncreated")
	tracker_manager.listener()	

