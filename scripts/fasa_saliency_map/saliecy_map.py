#!/usr/bin/env python

# ROS version written by Minkyu Kim

#The MIT License (MIT)
#Copyright (c) 2016 Massimiliano Patacchiola
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
#MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
#CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
#SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#In this example the Particle Filter is used in order to stabilise some noisy detection.
#The Backprojection algorithm is used in order to find the pixels that have the same HSV 
#histogram of a predefined template. The template is a subframe of the main image or an external
#matrix that can be used as a filter. We track the object taking the contour with the largest area
#returned by a binary mask (blue rectangle). The center of the contour is the tracked point. 
#To test the Particle Filter we inject noise in the measurements returned by the Backprojection. 
#The Filter can absorbe the noisy measurements, giving a stable estimation of the target center (green dot).

#COLOR CODE:
#BLUE: the rectangle containing the target. Noise makes it shaky (unstable measurement).
#GREEN: the point estimated from the Particle Filter.
#RED: the particles generated by the filter.

import cv2
import roslib
import sys
import rospy
import numpy as np
from timeit import default_timer as timer
from deepgaze.saliency_map import FasaSaliencyMapping 
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image
from os import listdir
import os

# If True it prints the time for processing the frame.
PRINT_TIME = False

# Using OpenCV the resolution of the webcam is set to these values.
# You must check which resolution your webcam support and adjust the values in accordance.
RESOLUTION_WIDTH = 640
RESOLUTION_HEIGHT = 480

class SaliencyManager(object):
    def __init__(self, wait=0.0):

        self.saliency_map = FasaSaliencyMapping(RESOLUTION_HEIGHT,RESOLUTION_WIDTH)
        image_topic = "/hsrb/head_rgbd_sensor/rgb/image_rect_color"
	rospy.Subscriber(image_topic, Image, self.image_callback)
        self.bridge = CvBridge()
	
    def image_callback(self,msg):
        # print('image_callback: ')
        try:
            frame   = self.bridge.imgmsg_to_cv2(msg,"bgr8")
            image_salient = self.saliency_map.returnMask(frame, tot_bins=8, format='BGR2LAB')
            image_salient = cv2.GaussianBlur(image_salient, (3,3), 1)  # applying gaussin blur to make it pretty
            cv2.imshow("image_window", image_salient)
            cv2.waitKey(1)
            # if cv2.waitKey(3) & 0xFF == ord('q'):
                # break #Exit when Q is pressed

        except CvBridgeError, e:
            print(e)

    def listener(self,wait=0.0):
        rospy.spin() 


if __name__ == '__main__':
        rospy.init_node('saliency_map_node')
        saliency_manager = SaliencyManager(sys.argv[1] if len(sys.argv) >1 else 0.0)
	saliency_manager.listener()	

